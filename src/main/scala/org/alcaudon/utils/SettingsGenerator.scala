package org.alcaudon.utils

import java.io.{BufferedWriter, File, FileWriter}

import com.typesafe.config._

import scala.collection.JavaConverters._

object SettingsGenerator extends App {

  val destination = "src/main/scala/org/alcaudon/core/SettingsDefinition.scala"

  val isDuration =
    "^(\\d+\\s*(milliseconds|ms|seconds|s|minutes|m|hours|h|days|d))$".r
  val isBoolean = "^(on|off|false|true)$".r
  val isSize = "^(\\d+\\s*(G|M|b|K))$".r

  val skipPaths = List("")

  implicit class FormattedString(val s: String) extends AnyVal {
    def capitalized = "-(.)".r.replaceAllIn(s, g => g.group(1).toUpperCase)
  }
  ConfigFactory.load()
  // Get all files under main/**/reference.conf, and concatenate them
  val rootConfig = ConfigFactory.load().resolve()

  def parse(path: String,
            config: ConfigObject,
            prefix: String,
            string: StringBuilder): Unit = {
    for (item <- config.entrySet.asScala.toList.sortBy(_.getKey)) {
      item.getValue match {
        case c: ConfigObject =>
          val base = new StringBuilder

          if (c.containsKey("TRAIT")) {
            for (traitName <- c.get("TRAIT").unwrapped.toString.split(",")) {
              base.append(if (base.length == 0) " extends " else " with ")
              base.append(traitName)
            }
          }

          val nextPath = s"$path.${item.getKey}"
          if (!skipPaths.exists(_ == nextPath)) {
            string.append(
              s"\n${prefix}object ${item.getKey.capitalized}$base {\n")
            parse(nextPath, c, prefix + "  ", string)
            string.append(s"$prefix}\n\n")
          }

        case s: ConfigValue =>
          val fullPath = s"$path.${item.getKey}"
          val accessor = s.valueType match {
            case ConfigValueType.BOOLEAN => "config.getBoolean"
            case ConfigValueType.LIST => "getStringList"
            // case ConfigValueType.NULL =>
            case ConfigValueType.NUMBER => "config.getInt"
            case ConfigValueType.STRING =>
              rootConfig.getString(fullPath) match {
                case isDuration(_, _) => "getDuration"
                case isSize(_, _) => "config.getBytes"
                case isBoolean(_) => "config.getBoolean"
                case _ => "config.getString"
              }
            case other =>
              println("[WARNING] Can't access " + other)
              ""
          }

          if (accessor != "") {
            string.append(
              s"${prefix}final lazy val ${item.getKey.capitalized} = $accessor(")
            string.append("\"" + fullPath + "\")\n")
          }
        case _ =>
          println(item.getValue.getClass)
          println("[WARNING] Ignore " + item)
      }
    }
  }

  val string = new StringBuilder

  string.append("package org.alcaudon.core\n\n")
  string.append(s"\n// -- AutoGenerated --\n\n")
  string.append("import scala.collection.JavaConversions._\n")
  string.append("import scala.concurrent.duration.Duration\n\n")
  string.append("import java.util.concurrent.TimeUnit.NANOSECONDS\n\n")
  string.append(
    "class SettingsDefinition(config: com.typesafe.config.Config) {\n\n")
  string.append(
    "  def getStringList(path: String) = config.getStringList(path).toList\n\n")
  string.append(
    "  def getDuration(path: String) = Duration.fromNanos(config.getDuration(path, NANOSECONDS))\n\n")
  parse("alcaudon", rootConfig.getObject("alcaudon"), "  ", string)
  string.append("}\n")

  println("Generate " + destination)

  val file = new File(destination)
  val bw = new BufferedWriter(new FileWriter(file))
  bw.write(string.result)
  bw.close()
}
